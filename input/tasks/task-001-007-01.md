---
id: task-001-007-01
story: story-001-007
epic: epic-001
title: Implement and run WAL mode concurrency validation test
complexity: 2
---

# Task: Implement and run WAL mode concurrency validation test

## Description
Create a test script that validates SQLite WAL mode concurrent access. The script launches a background thread that performs sustained writes (100+ rows with small delays) to a test table while the main thread concurrently reads from the same database. Document observed behavior: whether reads are non-blocking, any lock timeout scenarios, and timing data. Produce pass/fail result and findings document.

## Acceptance Criteria
- [ ] Test script creates a test database with WAL mode via the connection manager from story-001-004
- [ ] Background thread inserts 100+ rows into a test table with small delays between batches
- [ ] Main thread performs concurrent reads while writes are in progress
- [ ] Confirms PRAGMA journal_mode returns 'wal'
- [ ] Produces pass/fail result with timing data (e.g., "100 reads in Xms while 500 rows written")
- [ ] Documents findings in `docs/spike-wal-concurrency.md`: observed behavior, any lock scenarios, effective concurrency level, mitigation strategies if issues found

## Technical Notes
- Use two separate connections (one per thread) via get_connection() from db.py
- Python threading with sqlite3: use separate connections per thread (check_same_thread=False already set in connection manager)
- Expected outcome: WAL mode works fine (single writer, few readers) for this project's use case
- If spike reveals issues, document mitigations: retry on SQLITE_BUSY, busy_timeout setting
- Time-box: ~0.5 days total
- Use threading.Thread or concurrent.futures.ThreadPoolExecutor

## Files to Create/Modify
- `scripts/test_wal_concurrency.py` (new test script)
- `docs/spike-wal-concurrency.md` (new findings document)
