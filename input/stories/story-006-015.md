---
id: story-006-015
epic: epic-006
title: Define MonitoredInstrument Protocol
priority: high
story_points: [TBD]
source_requirements: [PIPE-058]
dependencies: []
blocks: [story-006-019]
---

# Story: Define MonitoredInstrument Protocol

## Description
Define a shared Python Protocol (typing.Protocol) that both real positions and simulated predictions can satisfy, enabling the same exit condition cascade to evaluate both instrument types. The protocol captures the common interface: instrument_type, entry/current/peak prices or premiums, remaining quantities, open_date, trailing_stop_active, and expiration_date (for options). This is the architectural bridge between position management and prediction monitoring.

## Acceptance Criteria
- [ ] A MonitoredInstrument Protocol is defined using `typing.Protocol` with `@runtime_checkable` decorator
- [ ] Protocol exposes unified property names: `instrument_type` ('stock' or 'option'), `entry_price` (returns entry premium for options, stock price for stocks), `current_price` (returns current premium for options, stock price for stocks), `peak_price` (returns peak premium for options, peak stock price for stocks), `remaining_quantity` (returns contracts_remaining for options, shares_remaining for stocks), `open_date`, `trailing_stop_active`
- [ ] Options instruments additionally expose: `expiration_date` and a computed `dte` property (calendar days to expiration)
- [ ] Both the Position model and the Prediction model can satisfy the protocol (structural subtyping)
- [ ] A unit test verifies that both Position and Prediction model instances pass `isinstance(obj, MonitoredInstrument)` checks using runtime_checkable
- [ ] Exit condition functions (stories 002-007) accept MonitoredInstrument rather than concrete Position type
- [ ] Protocol includes an `is_real_position` boolean property to distinguish real positions (affect portfolio cash) from predictions (no cash impact)
- [ ] Protocol is documented with docstrings explaining each field's semantics and expected types

## Technical Notes
- PIPE-058: Phase 6 monitoring uses a shared MonitoredInstrument interface for both positions and predictions.
- Use Python's typing.Protocol with @runtime_checkable for structural subtyping (duck typing with type safety).
- The unified `entry_price` property resolves the field aliasing issue: for options, entry_price IS the entry premium. Exit condition functions do not need to branch on instrument_type for price lookups.
- The protocol must be defined before prediction monitoring (story-006-019) can be implemented.
- This also impacts epic-005 (Position model must satisfy the protocol) and epic-009 (Prediction model must satisfy the protocol).
- The key distinction between positions and predictions at runtime: positions update portfolio cash, predictions do not. Use `is_real_position` to discriminate.
- Exit functions access stop/take-profit thresholds from system_config independently (not via the Protocol). The Protocol provides price data; threshold logic lives in the exit functions.
- Architect caveat: this is a shared interface that must be coordinated across epics.

## Dependencies
- Depends on: none (protocol definition is foundational)
- Blocks: story-006-019 (prediction monitoring needs the protocol), stories in epic-005 and epic-009 that implement the protocol
